# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from asyncio.windows_events import NULL
from fileinput import filename
from pydoc import classname
from sre_parse import GLOBAL_FLAGS
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QDialog, QApplication, QFileDialog

from skimage.transform import resize
from skimage.io import imread

import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np
import os
import cv2
import random
from tensorflow import keras
import datetime


from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten
from keras.layers import Conv2D, MaxPooling2D
# more info on callbakcs: https://keras.io/callbacks/ model saver is cool too.

from keras.callbacks import TensorBoard

import openpyxl
from openpyxl import Workbook

import pickle
import time
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification
from sklearn.metrics import plot_confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import confusion_matrix
import seaborn as sns

import os
import torch
import torch.nn
import torchvision.models as models
import torchvision.transforms as transforms
import torch.nn.functional as F 
import torchvision.utils as utils
import cv2 
import matplotlib.pyplot as plt
import numpy as np 
from PIL import Image
import argparse

global model

global CATEGORIES

CATEGORIES = []

global actual_int

global fname, model_name
global loaded_file
global size1,size2

fname = 'a'

fname2 = 'a'

class_file = 'a'

model_name = 'a'

actual_int = NULL

loaded_file = 0
size1 = 0
size2 = 0




class Ui_MainWindow(object):






    def button_clicked(self):
        print("you pressed the button")

        self.label_2.setText("Loading Model")

        global model, model_name

        print("Model name is ", model_name)

        #
        ####prediction = model.predict([prepare('C:/Users/Abbad/Desktop/Sommer
        # 22/Project/doggo.jpg')])
        
        # model=pickle.load(open('SVM_model.p','rb'))

        if model_name == "AlexNet":
            model = models.alexnet(pretrained=True)
            # put the model to eval mode for testing
            model.eval()
            self.label_2.setText("AlexNet Model Loaded")

        if model_name == "Random CNN":
            
            model = tf.keras.models.load_model("64x3-CNN.model")
            self.label_2.setText("Random CNN Loaded")

        if model_name == "Random SVM":
            print("Model name is ", model_name)

            # Categories=['Dog','Cat']

            model=pickle.load(open('SVM_model.p','rb'))

            self.label_2.setText("Random SVM Loaded")

        if model_name == "LeNet":

            print("Model name is ", model_name)

            model = tf.keras.models.load_model("LeNet.model")
            self.label_2.setText("LeNet Loaded")

        if model_name == "Random MLP":

            print("Model name is ", model_name)

            model = tf.keras.models.load_model("MLP.model")
            self.label_2.setText("Random MLP Loaded")

        if model_name == "ResNet":
    
            print("Model name is ", model_name)

            model = tf.keras.models.load_model("ResNet.model")
            self.label_2.setText("ResNet Loaded")


        if model_name == "None":
            self.label_2.setText("No Model Loaded")




    def button_clicked2(self): ## Read Data

        def prepare(filepath):
            global size1,size2
            IMG_SIZE = 100  # 50 in txt-based

            if size1 == 0:
                size1 = 100
                size2 = 100

            if model_name == "LeNet":
                size1 = 32
                size2 = 32

            size1 = int(size1)
            size2 = int(size2)

            print("size1=", size1)

            print("size2=", size2)

            img_array = cv2.imread(filepath, cv2.IMREAD_GRAYSCALE)
            new_array = cv2.resize(img_array, (size1, size2))


            

            return new_array.reshape(-1, size1, size2, 1)


      
        directory_in_str = fname

        directory = os.fsencode(directory_in_str)

        wb = Workbook()

        # grab the active worksheet
        ws = wb.active

        # Data can be assigned directly to cells
        #ws['A1'] = 42

        # Rows can also be appended
        ws.append(["File Name", "Category 1 Name", "Category 2 Name", "Predicted Value", "Predicted Int", "Actual Int" , "Total Files",  "TP", "TN", "FP", "FN", "TPR",
                "TNR","FPR","FNR", "F1-Score", "ROC"])
            
        for file in os.listdir(directory):
            filename = os.fsdecode(file)
            print("filename=", filename)
            path = fname + "/" + filename
            print("path=", path)

        
            print("model_name=", model_name)

            
            print("loaded_file=", loaded_file)





            # img=imread(path)
    
            # img_resize=resize(img,(150,150,3))
            # l=[img_resize.flatten()]
            # prediction = model.predict(l)[0]

            # print("The predicted image is : "+CATEGORIES[model.predict(l)[0]])

            # Predicted_Value = CATEGORIES[model.predict(l)[0]]


            if model_name == "AlexNet":



                # Predicted_Int = int(model.predict(l)[0])
                data_transforms = transforms.Compose([
                    transforms.Resize((224,224)),             # resize the input to 224x224
                    transforms.ToTensor(),              # put the input to tensor format
                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])  # normalize the input
                    # the normalization is based on images from ImageNet
                ])


                # open the testing image
                img = Image.open(path) 
                print("original image's shape: " + str(img.size))
                # pre-process the input
                transformed_img = data_transforms(img)
                print("transformed image's shape: " + str(transformed_img.shape))
                # form a batch with only one image
                batch_img = torch.unsqueeze(transformed_img, 0)
                print("image batch's shape: " + str(batch_img.shape))


                output = model(batch_img)
                print("output vector's shape: " + str(output.shape))

                

                # map the class no. to the corresponding label
                with open(class_name[0]) as labels:
                    classes = [i.strip() for i in labels.readlines()]
                
                # print the first 5 classes to see the labels
                print("\nprint the first 5 classes to see the lables")
                for i in range(2):
                    print("class " + str(i) + ": " + str(classes[i]))
                
                # sort the probability vector in descending order
                sorted, indices = torch.sort(output, descending=True)
                percentage = F.softmax(output, dim=1)[0] * 100.0

                print("classes: ", classes)
                global CATEGORIES
                CATEGORIES = classes
                print("percentage: ", percentage)
                print("indices: ", indices[0][:2])
                # obtain the first 5 classes (with the highest probability) the input belongs to
                results = [(classes[i], percentage[i].item()) for i in indices[0][:2]]
                print("results: ", results)

                Predicted_Value = results[0][0]

                print("indices = ",indices)

                indices = indices[0][:1].tolist()


                Predicted_Int = int(indices[0])

                print("Predicted_Int ",Predicted_Int)

                print("Predicted_Value ",Predicted_Value)

                if int(Predicted_Int) != int(actual_int):

                    Predicted_Int = int(actual_int) + 1
                
                print("Predicted_Int ",Predicted_Int)


                print("actual_int ",actual_int)


                ws.append([filename, CATEGORIES[int(actual_int)], CATEGORIES[int(actual_int)], Predicted_Value, int(Predicted_Int), int(actual_int)])

                # Save the file
                global fname2

                report_file_name = fname2 + "/report.xlsx"
                print("report_file_name = ",report_file_name)

                wb.save(report_file_name)
                self.label_2.setText('Evaluation Done')



            if model_name == "Random CNN":
                
                


                print("CNN_CATEGORIES", CATEGORIES)


                if loaded_file == 2: ## Loaded manually

                    #print("Image Sieze  ",[prepare(path)])    
                    prediction = model.predict([prepare(path)])



                    Predicted_Value = CATEGORIES[int(prediction[0][0])]

                    Predicted_Int = int(prediction[0][0])

                    print("Predicted_Int ",Predicted_Int)

                    print("Predicted_Value ",Predicted_Value)

                    print("actual_int ",actual_int)
                    ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])

                    # Save the file

                    report_file_name = fname2 + "/report.xlsx"
                    print("report_file_name = ",report_file_name)

                    wb.save(report_file_name)

                    self.label_2.setText('Evaluation Done')



                if loaded_file == 1: ## Loaded through file

                    prediction = model.predict([prepare(path)])

    
                    with open(class_name[0]) as labels:
                        classes = [i.strip() for i in labels.readlines()]
                        CATEGORIES = classes

                    Predicted_Value = CATEGORIES[int(prediction[0][0])]

                    Predicted_Int = int(prediction[0][0])

                    print("Predicted_Int ",Predicted_Int)

                    print("Predicted_Value ",Predicted_Value)

                    print("actual_int ",actual_int)

                    # print the first 5 classes to see the labels
                    print("\nprint the first 5 classes to see the lables")
                    for i in range(2):
                        print("class " + str(i) + ": " + str(classes[i]))

                    ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])

                    # Save the file

                    report_file_name = fname2 + "/report.xlsx"
                    print("report_file_name = ",report_file_name)

                    wb.save(report_file_name)

                    self.label_2.setText('Evaluation Done')



            if model_name == "LeNet":
                print("Lenet")


                if loaded_file == 2: ## Loaded manually

                    #print("Image Sieze  ",[prepare(path)])    
                    prediction = model.predict([prepare(path)])



                    Predicted_Value = CATEGORIES[int(prediction[0][0])]

                    Predicted_Int = int(prediction[0][0])

                    print("Predicted_Int ",Predicted_Int)

                    print("Predicted_Value ",Predicted_Value)

                    print("actual_int ",actual_int)


                if loaded_file == 1: ## Loaded through file

                    prediction = model.predict([prepare(path)])

    
                    with open(class_name[0]) as labels:
                        classes = [i.strip() for i in labels.readlines()]
                        CATEGORIES = classes

                    Predicted_Value = CATEGORIES[int(prediction[0][0])]

                    Predicted_Int = int(prediction[0][0])

                    print("Predicted_Int ",Predicted_Int)

                    print("Predicted_Value ",Predicted_Value)

                    print("actual_int ",actual_int)

                    # print the first 5 classes to see the labels
                    print("\nprint the first 5 classes to see the lables")
                    for i in range(2):
                        print("class " + str(i) + ": " + str(classes[i]))

                ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])

                # Save the file

                report_file_name = fname2 + "/report.xlsx"
                print("report_file_name = ",report_file_name)

                wb.save(report_file_name)

                self.label_2.setText('Evaluation Done')

            if model_name == "Random SVM":
        

                img=imread(path)
 
                img_resize=resize(img,(150,150))
                l=[img_resize.flatten()]

                print("The predicted image is : "+CATEGORIES[model.predict(l)[0]])
                print(f'Is the image a {CATEGORIES[model.predict(l)[0]]} ?(y/n)')

                Predicted_Value = CATEGORIES[model.predict(l)[0]]

                Predicted_Int = model.predict(l)[0]

                
                print("Predicted_Int ",Predicted_Int)

                print("Predicted_Value ",Predicted_Value)

                print("actual_int ",actual_int)


                ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])

                    # Save the file

                report_file_name = fname2 + "/report.xlsx"
                print("report_file_name = ",report_file_name)

                wb.save(report_file_name)

                self.label_2.setText('Evaluation Done')

            if model_name == "ResNet":
            

                image=imread(path)
                image_resized= cv2.resize(image, (180,180))
                image=np.expand_dims(image_resized,axis=0)

                pred=model.predict(image)

                output_class=CATEGORIES[np.argmax(pred)]

                print("The predicted int is", np.argmax(pred))
                print("The predicted class is", output_class)

                Predicted_Value = output_class

                Predicted_Int = np.argmax(pred)

                
                print("Predicted_Int ",Predicted_Int)

                print("Predicted_Value ",Predicted_Value)

                print("actual_int ",actual_int)


                # ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])
                ws.append([filename, CATEGORIES[int(Predicted_Int)], CATEGORIES[int(actual_int)], Predicted_Value, int(Predicted_Int), int(actual_int)])
                # ws.append(["File Name", "Category 1 Name", "Category 2 Name", "Predicted Value", "Predicted Int", "Actual Int" , "Total Files",  "TP", "TN", "FP", "FN", "TPR",
                # "TNR","FPR","FNR", "F1-Score", "ROC"])

                    # Save the file

                report_file_name = fname2 + "/report.xlsx"
                print("report_file_name = ",report_file_name)

                wb.save(report_file_name)

                self.label_2.setText('Evaluation Done')



            
            if model_name == "Random MLP":

                print(model_name)

                
                #print("Image Sieze  ",[prepare(path)])    
                prediction = model.predict([prepare(path)])



                Predicted_Value = CATEGORIES[int(prediction[0][0])]

                Predicted_Int = int(prediction[0][0])

                print("Predicted_Int ",Predicted_Int)

                print("Predicted_Value ",Predicted_Value)

                print("actual_int ",actual_int)
                ws.append([filename, CATEGORIES[0], CATEGORIES[1], Predicted_Value, int(Predicted_Int), int(actual_int)])

                # Save the file

                report_file_name = fname2 + "/report.xlsx"
                print("report_file_name = ",report_file_name)

                wb.save(report_file_name)

                self.label_2.setText('Evaluation Done')
    






    def button_clicked3(self): #Confusion Matrix

        print("you pressed the button3")


        def make_confusion_matrix(cf,
                          group_names=None,
                          categories='auto',
                          count=True,
                          percent=True,
                          cbar=True,
                          xyticks=True,
                          xyplotlabels=True,
                          sum_stats=True,
                          figsize=None,
                          cmap='Blues',
                          title=None):
   


            # CODE TO GENERATE TEXT INSIDE EACH SQUARE
            blanks = ['' for i in range(cf.size)]

            if group_names and len(group_names)==cf.size:
                group_labels = ["{}\n".format(value) for value in group_names]
            else:
                group_labels = blanks

            if count:
                group_counts = ["{0:0.0f}\n".format(value) for value in cf.flatten()]
            else:
                group_counts = blanks

            if percent:
                group_percentages = ["{0:.2%}".format(value) for value in cf.flatten()/np.sum(cf)]
            else:
                group_percentages = blanks

            box_labels = [f"{v1}{v2}{v3}".strip() for v1, v2, v3 in zip(group_labels,group_counts,group_percentages)]
            box_labels = np.asarray(box_labels).reshape(cf.shape[0],cf.shape[1])


            # CODE TO GENERATE SUMMARY STATISTICS & TEXT FOR SUMMARY STATS
            if sum_stats:
                #Accuracy is sum of diagonal divided by total observations
                accuracy  = np.trace(cf) / float(np.sum(cf))

                print("accuracy", accuracy)

                print("len(cf)",len(cf))

                #if it is a binary confusion matrix, show some more stats
                if len(cf)==2:
                    #Metrics for Binary Confusion Matrices
                    precision = cf[1,1] / sum(cf[:,1])
                    recall    = cf[1,1] / sum(cf[1,:])

                    print("cf[1,1] = ",cf[1,1])
                    print("sum(cf[:,1]) = ",sum(cf[:,1]))


                    global true_postive, false_negative, true_negative, false_positive , true_postive_rate, false_negative_rate, true_negative_rate, false_positive_rate, f1_score

                    true_postive_rate = cf[1,1] /sum(cf[1,:])
                    true_postive = cf[1,1]
                    print("true_postive_rate",true_postive_rate)

                    false_negative_rate = cf[1,0] /sum(cf[1,:])
                    false_negative = cf[1,0]
                    print("false_negative_rate",false_negative_rate)

                    true_negative_rate = cf[0,0] /sum(cf[0,:])
                    true_negative = cf[0,0]
                    print("true_negative_rate",true_negative_rate)

                    false_positive_rate = cf[0,1] /sum(cf[0,:])
                    false_positive = cf[0,1]
                    print("false_positive_rate",false_positive_rate)


                    f1_score  = 2*precision*recall / (precision + recall)

                    stats_text = "\nTrue Postive Rate={:0.3f}  False Negative Rate={:0.3f}\nTrue Negative Rate={:0.3f}  False Positive Rate={:0.3f}\nAccuracy={:0.3f}\nPrecision={:0.3f}\nRecall={:0.3f}\nF1 Score={:0.3f}".format(
                        true_postive_rate,false_negative_rate,true_negative_rate,false_positive_rate,accuracy,precision,recall,f1_score)
                else:
                    stats_text = "\n\nAccuracy={:0.3f}".format(accuracy)
            else:
                stats_text = ""


            # SET FIGURE PARAMETERS ACCORDING TO OTHER ARGUMENTS
            if figsize==None:
                #Get default figure size if not set
                figsize = plt.rcParams.get('figure.figsize')

            if xyticks==False:
                #Do not show categories if xyticks is False
                categories=False




            # MAKE THE HEATMAP VISUALIZATION
            plt.figure(figsize=figsize)
            sns.heatmap(cf,annot=box_labels,fmt="",cmap=cmap,cbar=cbar,xticklabels=categories,yticklabels=categories)

            if xyplotlabels:
                plt.ylabel('Actual Values')
                plt.xlabel('Predicted Values' + stats_text)
            else:
                plt.xlabel(stats_text)
            
            if title:
                plt.title(title)
    




        
        
        global fname2

        report_file_name = fname2 + "/report.xlsx"
        
        df = pd.read_excel(report_file_name, header=None, converters={'Predicted Int':int,'Actual Int':int}) # can also index sheet by name or fetch all sheets

        y = df[4].tolist()
        X = df[5].tolist()

        X = X[1:]

        y = y[1:]

        print( 'X',X)
        print('Y',y)

        cf_matrix = confusion_matrix(X, y)
        print('cf_matrix',cf_matrix)

        

        labels = ['True Negative','False Positive','False Negative','True Positive']
        print('make_confusion_matrix')
        make_confusion_matrix(cf_matrix, 
                            group_names=labels,
                            title= "Confusion Matrix",
                            sum_stats = True)

        # print("prediction", prediction)


        # print([int(model.predict(l)[0])])  # will be a list in a list.

        # print(CATEGORIES[int(model.predict(l)[0])])

        # self.label_2.setText(CATEGORIES[int(model.predict(l)[0])])

        # print("true_negative", true_negative)


        # ws.append(["All Files", "NULL", "NULL", "NULL", "NULL", "NULL", len(X), true_postive, true_negative, false_positive , false_negative,  true_postive_rate,  true_negative_rate, false_positive_rate, false_negative_rate, f1_score ])

        # # Save the file

        # wb.save("sample.xlsx")


        # self.label_2.setText("Report Generated")
        plt.tight_layout()

        #plt.show()
        

        matrix_file_name = fname2 + "/sample.png"
        

        plt.savefig(matrix_file_name)

        self.label_2.setText("Report and Confusion Matrix Generated")

    def button_clicked4(self): #Input Folder
        
        print("you pressed the button4")
        global fname

        fname = QFileDialog.getExistingDirectory(None, 'Select file')
        print(fname)
        self.label_2.setText("Input Folder Selected")

    def button_clicked6(self): #Output Folder
            
        print("you pressed the button6")
        global fname2

        fname2 = QFileDialog.getExistingDirectory(None, 'Select file')
        print(fname2)
        self.label_2.setText("Output Folder Selected")

    def button_clicked7(self):#Categories File Added
            
        print("you pressed the Class name")
        global class_name

        class_name = QFileDialog.getOpenFileName(None, 'Select file')
        print("class_name", class_name)
        print("class_name[0]", class_name[0])\

        global loaded_file


        loaded_file = 1

        self.label_2.setText("Categories File Selected")

    def button_clicked8(self):
            
        print("you pressed the Model name save")
        global model_name

        model_name = self.comboBox.currentText()
        
       
        print("model_name", model_name)
     
        self.label_2.setText("Model Selected")

    
    def button_clicked9(self):#Image Size
                
        print("you pressed the input size save")
        global size1,size2


   
        #["Cat", "Dog"]


        if size1 != '':
            size1 = self.lineEdit_3.text()
            size2 = self.lineEdit_4.text()

        print(size1)
        print(size2)
     
        self.label_2.setText("Size Saved")

    def button_clicked5(self): #saving Categories
            
        print("you pressed the Categories save")



        text1 = self.lineEdit.text()
        text2 = self.lineEdit_2.text()
        #["Cat", "Dog"]
        print(text1)
        print("text2", text2)


        global CATEGORIES, actual_int

        global loaded_file

        if text1 != NULL:
            try:

                CATEGORIES = list(text1.split(","))
                print("CATEGORIES", CATEGORIES)

                actual_int = text2

                print("actual_int", actual_int)



                loaded_file = 2
                self.label_2.setText("Categories Saved")


            except:
                print("No Categories")











    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        MainWindow.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(80, 180, 111, 31))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.button_clicked)
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(90, 20, 631, 91))
        font = QtGui.QFont()
        font.setFamily("Arial Rounded MT Bold")
        font.setPointSize(16)
        font.setBold(False)
        font.setWeight(50)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(80, 240, 151, 28))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(self.button_clicked2)
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(80, 400, 93, 28))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.clicked.connect(self.button_clicked3)

        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(410, 230, 271, 31))
        self.label_2.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_2.setText("")
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(580, 430, 211, 141))
        self.label_3.setText("")
        self.label_3.setPixmap(QtGui.QPixmap("FRA-UAS_Logo_rgb.jpg"))
        self.label_3.setScaledContents(True)
        self.label_3.setWordWrap(True)
        self.label_3.setObjectName("label_3")
        self.pushButton_4 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_4.setGeometry(QtCore.QRect(80, 290, 151, 31))
        self.pushButton_4.setObjectName("pushButton_4")
        self.pushButton_4.clicked.connect(self.button_clicked4)

        self.pushButton_6 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_6.setGeometry(QtCore.QRect(80, 340, 151, 31))
        self.pushButton_6.setObjectName("pushButton_6")
        self.pushButton_6.clicked.connect(self.button_clicked6)

        self.pushButton_7 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_7.setGeometry(QtCore.QRect(600, 500, 130, 28))
        self.pushButton_7.setObjectName("pushButton_7")
        self.pushButton_7.clicked.connect(self.button_clicked7)

        self.pushButton_8 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_8.setGeometry(QtCore.QRect(260, 130, 151, 31))
        self.pushButton_8.setObjectName("pushButton_8")
        self.pushButton_8.clicked.connect(self.button_clicked8)

        self.pushButton_9 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_9.setGeometry(QtCore.QRect(680, 120, 110, 31))
        self.pushButton_9.setObjectName("pushButton_9")
        self.pushButton_9.clicked.connect(self.button_clicked9)


        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")        
        self.comboBox.setObjectName("comboBox")
        self.comboBox.setGeometry(QtCore.QRect(80, 130, 141, 31))
        font2 = QtGui.QFont()
        font2.setPointSize(10)
        self.comboBox.setFont(font2)

        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(90, 500, 180, 21))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_4.setFont(font)
        self.label_4.setObjectName("label_4")
        self.label_5 = QtWidgets.QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(90, 450, 161, 21))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")

        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(450, 130, 161, 21))
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_6.setFont(font)
        self.label_6.setObjectName("label_6")

        self.label_7 = QtWidgets.QLabel(self.centralwidget)
        self.label_7.setGeometry(QtCore.QRect(530, 110, 161, 21))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_7.setFont(font)
        self.label_7.setObjectName("label_7")

        self.label_8 = QtWidgets.QLabel(self.centralwidget)
        self.label_8.setGeometry(QtCore.QRect(600, 110, 161, 21))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")

        self.label_9 = QtWidgets.QLabel(self.centralwidget)
        self.label_9.setGeometry(QtCore.QRect(586, 134, 10, 10))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.label_9.setFont(font)
        self.label_9.setObjectName("label_9")

        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(280, 500, 113, 22))
        self.lineEdit.setObjectName("lineEdit")
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(280, 450, 113, 22))
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.lineEdit_3 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_3.setGeometry(QtCore.QRect(530, 130, 50, 22))
        self.lineEdit_3.setObjectName("lineEdit_3")

        self.lineEdit_4 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_4.setGeometry(QtCore.QRect(600, 130, 50, 22))
        self.lineEdit_4.setObjectName("lineEdit_4")

        self.pushButton_5 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_5.setGeometry(QtCore.QRect(460, 500, 111, 28))
        self.pushButton_5.setObjectName("pushButton_5")
        self.pushButton_5.clicked.connect(self.button_clicked5)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 808, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "Load Algorithm"))
        self.label.setText(_translate("MainWindow", "Test System For Pretrained Decision Algorithms"))
        self.pushButton_2.setText(_translate("MainWindow", "Read Data / Print Result"))
        self.pushButton_3.setText(_translate("MainWindow", "Print Report"))
        self.pushButton_4.setText(_translate("MainWindow", "Select Input Folder"))
        self.pushButton_6.setText(_translate("MainWindow", "Select Output Folder"))
        self.pushButton_7.setText(_translate("MainWindow", "Select Categories File"))
        self.pushButton_8.setText(_translate("MainWindow", "Save Model Name"))
        self.pushButton_9.setText(_translate("MainWindow", "Save Image Size"))

        self.label_4.setText(_translate("MainWindow", "Classification Categories/Labels"))
        self.label_5.setText(_translate("MainWindow", "Actual Value(Int)"))
        self.label_6.setText(_translate("MainWindow", "Input Size"))
        self.label_7.setText(_translate("MainWindow", "Width"))
        self.label_8.setText(_translate("MainWindow", "Height"))
        self.label_9.setText(_translate("MainWindow", "X"))




        self.pushButton_5.setText(_translate("MainWindow", "Save Categories"))

        self.comboBox.setItemText(0, _translate("MainWindow", u"None", None))
        self.comboBox.setItemText(1, _translate("MainWindow", u"AlexNet", None))
        self.comboBox.setItemText(2, _translate("MainWindow", u"Random CNN", None))
        self.comboBox.setItemText(3, _translate("MainWindow", u"Random SVM", None))
        self.comboBox.setItemText(4, _translate("MainWindow", u"LeNet", None))
        self.comboBox.setItemText(5, _translate("MainWindow", u"Random MLP", None))
        self.comboBox.setItemText(6, _translate("MainWindow", u"ResNet", None))


        

        


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
